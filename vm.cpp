#include "vm.h"
#include "builtins.h"
#include "code.h"
#include "compiler.h"
#include "eval.h"
#include "object.h"
#include <cstdint>
#include <iostream>
#include <map>
#include <memory>
#include <optional>

// TODO: add better error handling rather than just returning integers. Probably
// by making some kind of error class or something since enums aren't different
// from integers.

// TODO: Start using unique pointers since using raw pointers and returning raw
// pointers is not best practice.

// TODO: After doing some research I think that using std::optional<std::string>
// where the string is the error message is the way to go with proper error
// handling. Since then I don't have to hardcode multiple different errors
// values into enums or something similar.

Object *native_bool_to_obj(bool val) {
	return (val ? object_constant::TRUE_OBJ : object_constant::FALSE_OBJ);
}

bool is_truthy(Object *obj) {
	if (obj == nullptr)
		return false;

	if (obj->Type() == ObjType::Boolean)
		return ((Boolean *)obj)->value;
	else if (obj->Type() == ObjType::Null)
		return false;

	return true;
}

// create vm instance from bytecode generated by compiler.
VM::VM(Bytecode *bytecode) {
	sp_ = 0;
	constants_ = bytecode->constants;
	stack_ = std::vector<Object *>(StackSize, nullptr);
	globals_ = std::vector<Object *>(GlobalsSize);

	std::unique_ptr<Frame> main_frame(new Frame(bytecode->instructions, 0));

	frames_ = std::array<std::unique_ptr<Frame>, MaxFrames>();
	frames_[0] = std::move(main_frame);

	frames_index_ = 1;
}

// return the topmost element in stack.
Object *VM::stack_top() {
	if (sp_ == 0)
		return nullptr;

	return stack_[sp_ - 1];
}

std::optional<std::string> VM::run() {
	for (current_frame().ip_ = 0;
			 current_frame().ip_ < (int)current_frame().instructions().size();
			 ++current_frame().ip_) {
		auto &ip = current_frame().ip_;
		const auto &inst = current_frame().instructions();
		const auto op = inst[ip];

		switch (op) {
		case code::OpConstant: {
			auto const_index = code::decode_uint16(
					code::Instructions(inst.begin() + ip + 1, inst.begin() + ip + 3));
			current_frame().ip_ += 2;

			auto status = push(constants_[const_index]);
			if (status.has_value())
				return status.value();

			break;
		}
		case code::OpPop: {
			pop();
			break;
		}
		case code::OpMul:
		case code::OpDiv:
		case code::OpSub:
		case code::OpAdd: {
			auto status = execute_binary_operation(op);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpTrue: {
			auto status = push(object_constant::TRUE_OBJ);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpFalse: {
			auto status = push(object_constant::FALSE_OBJ);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpEqual:
		case code::OpNotEqual:
		case code::OpGreaterThan: {
			auto status = execute_comparison(op);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpBang: {
			auto status = execute_bang_operator();
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpMinus: {
			auto status = execute_minus_operator();
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpJump: {
			auto pos = (int)code::decode_uint16(
					code::Instructions(inst.begin() + ip + 1, inst.begin() + ip + 3));
			current_frame().ip_ = pos - 1;
			break;
		}
		case code::OpJumpNotTruthy: {
			auto pos = (int)code::decode_uint16(
					code::Instructions(inst.begin() + ip + 1, inst.begin() + ip + 3));
			current_frame().ip_ += 2;

			auto condition = pop();
			if (!is_truthy(condition))
				current_frame().ip_ = pos - 1;
			break;
		}
		case code::OpNull: {
			auto status = push(object_constant::null);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpSetGlobal: {
			auto global_index = code::decode_uint16(
					code::Instructions(inst.begin() + ip + 1, inst.begin() + ip + 3));
			current_frame().ip_ += 2;

			globals_[global_index] = pop();
			break;
		}
		case code::OpGetGlobal: {
			auto global_index = code::decode_uint16(
					code::Instructions(inst.begin() + ip + 1, inst.begin() + ip + 3));
			current_frame().ip_ += 2;

			auto status = push(globals_[global_index]);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpArray: {
			auto num_elements = code::decode_uint16(
					code::Instructions(inst.begin() + ip + 1, inst.begin() + ip + 3));
			current_frame().ip_ += 2;
			auto array = build_array(sp_ - num_elements, sp_);
			sp_ -= num_elements;

			auto status = push(array);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpHash: {
			auto num_elements = code::decode_uint16(
					code::Instructions(inst.begin() + ip + 1, inst.begin() + ip + 3));
			current_frame().ip_ += 2;

			auto hash = build_hash(sp_ - num_elements, sp_);
			sp_ -= num_elements;
			auto status = push(hash);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpIndex: {
			auto index = pop();
			auto left = pop();

			auto status = execute_index_expression(left, index);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpCall: {
			auto num_args = (int)((std::uint8_t)inst[ip + 1]);
			current_frame().ip_ += 1;

			const auto status = execute_call(num_args);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpReturnValue: {
			auto return_value = pop();
			const auto &frame = pop_frame();
			sp_ = frame.base_pointer_ - 1;

			const auto status = push(return_value);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpReturn: {
			const auto &frame = pop_frame();
			sp_ = frame.base_pointer_ - 1;

			const auto status = push(object_constant::null);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpSetLocal: {
			auto local_index = (int)((std::uint8_t)inst[ip + 1]);
			current_frame().ip_ += 1;

			auto &frame = current_frame();
			stack_[frame.base_pointer_ + local_index] = pop();
			break;
		}
		case code::OpGetLocal: {
			auto local_index = (int)((std::uint8_t)inst[ip + 1]);
			current_frame().ip_ += 1;

			const auto &frame = current_frame();
			const auto status = push(stack_[frame.base_pointer_ + local_index]);
			if (status.has_value()) {
				return status.value();
			}
			break;
		}
		case code::OpGetBuiltin: {
			auto builtin_index = (int)((std::uint8_t)inst[ip + 1]);
			current_frame().ip_ += 1;

			// the compiler ensures that this index exists
			auto def = builtin_functions::functions[builtin_index];

			auto status = push(def.second);
			if (status.has_value())
				return status.value();
		}
		case code::OpClosure: {
			auto const_index = code::decode_uint16(
					code::Instructions(inst.begin() + ip + 1, inst.begin() + ip + 3));
			auto num_free = (int)((uint8_t)inst[ip + 3]);
			current_frame().ip_ += 3;

			auto status = push_closure(const_index, num_free);
			if (status.has_value())
				return status.value();
			break;
		}
		case code::OpGetFree: {
			auto free_idx = (int)((uint8_t)inst[ip + 1]);
			current_frame().ip_ += 1;

			const auto &curr_closure = current_frame().closure();
			auto status = push(curr_closure.free_[free_idx]);
			if (status.has_value())
				return status.value();

			break;
		}
		}
	}

	return std::nullopt;
}

// push item to the stack and check for stack overflow.
std::optional<std::string> VM::push(Object *obj) {
	if (sp_ >= StackSize)
		// stack overflow
		return "stack overflow";

	stack_[sp_] = obj;
	++sp_;

	return std::nullopt;
}

// pop the top element from the stack and return it.
Object *VM::pop() {
	auto obj = stack_[sp_ - 1];
	sp_--;

	return obj;
}

Object *VM::last_popped_stack_elem() { return stack_[sp_]; }

std::optional<std::string> VM::execute_binary_operation(code::Opcode op) {
	auto right = pop();
	auto left = pop();

	// check that types support a certain operation.
	if (left->Type() == ObjType::Integer && right->Type() == ObjType::Integer) {
		return execute_binary_integer_operation(op, left, right);
	} else if (left->Type() == ObjType::String &&
						 right->Type() == ObjType::String) {
		return execute_binary_string_operation(op, left, right);
	} else {
		// the types don't have a supported binary expression
		return "binary operation is not recognized for given types.";
	}
}

std::optional<std::string> VM::execute_binary_integer_operation(code::Opcode op,
																																Object *left,
																																Object *right) {
	auto left_val = ((Integer *)left)->value;
	auto right_val = ((Integer *)right)->value;

	int res;
	switch (op) {
	case code::OpAdd:
		res = left_val + right_val;
		break;
	case code::OpSub:
		res = left_val - right_val;
		break;
	case code::OpMul:
		res = left_val * right_val;
		break;
	case code::OpDiv:
		res = left_val / right_val;
		break;
	default:
		// operator not recognized
		return "binary integer operation is not recognized.";
	}

	return push(new Integer(res));
}

std::optional<std::string> VM::execute_comparison(code::Opcode op) {
	auto right = pop();
	auto left = pop();

	// check that types support a certain operation.
	if (left->Type() == ObjType::Integer && right->Type() == ObjType::Integer) {
		return execute_integer_comparison(op, left, right);
	}

	switch (op) {
	case code::OpEqual:
		return push(native_bool_to_obj(right == left));
	case code::OpNotEqual:
		return push(native_bool_to_obj(right != left));
	}

	// the operation is not recognized.
	return "comparison operator is not recognized";
}

std::optional<std::string>
VM::execute_integer_comparison(code::Opcode op, Object *left, Object *right) {
	auto left_value = ((Integer *)left)->value;
	auto right_value = ((Integer *)right)->value;

	switch (op) {
	case code::OpEqual:
		return push(native_bool_to_obj(right_value == left_value));
	case code::OpNotEqual:
		return push(native_bool_to_obj(right_value != left_value));
	case code::OpGreaterThan:
		return push(native_bool_to_obj(left_value > right_value));
	}

	return "integer comparison operator not supported";
}

std::optional<std::string> VM::execute_bang_operator() {
	auto oper = pop();
	if (oper == object_constant::TRUE_OBJ)
		return push(object_constant::FALSE_OBJ);
	else if (oper == object_constant::FALSE_OBJ)
		return push(object_constant::TRUE_OBJ);
	else if (oper == object_constant::null)
		return push(object_constant::TRUE_OBJ);

	return push(object_constant::FALSE_OBJ);
}

std::optional<std::string> VM::execute_minus_operator() {
	auto oper = pop();
	if (oper->Type() != ObjType::Integer)
		// type cannot be used in conjunction with integer type
		return "type cannot be used in conjunction with minus expression";

	auto value = ((Integer *)oper)->value;
	return push(new Integer(-value));
}

std::optional<std::string> VM::execute_binary_string_operation(code::Opcode op,
																															 Object *left,
																															 Object *right) {
	if (op != code::OpAdd)
		return "binary string operation not recognized has to be '+'";

	auto left_value = ((String *)left)->value;
	auto right_value = ((String *)right)->value;

	return push(new String(left_value + right_value));
}

Object *VM::build_array(int start_index, int end_index) {
	auto elements = std::vector<Object *>(end_index - start_index, nullptr);

	for (int i = start_index; i < end_index; ++i)
		elements[i - start_index] = stack_[i];

	return new Array(elements);
}

Object *VM::build_hash(int start_index, int end_index) {
	auto hashtable = new Hash();
	for (int i = start_index; i < end_index; i += 2) {
		auto key = stack_[i];
		auto value = stack_[i + 1];
		auto pair = new HashPair{key, value};

		if (!(key->Type() == ObjType::Integer || key->Type() == ObjType::String ||
					key->Type() == ObjType::Boolean))
			return nullptr;

		HashKey res;
		// we only need to check these types since the previous if expressions
		// guarantees that the object is one of them.
		if (key->Type() == ObjType::Integer)
			res = ((Integer *)key)->hash_key();
		else if (key->Type() == ObjType::String)
			res = ((String *)key)->hash_key();
		else if (key->Type() == ObjType::Boolean)
			res = ((Boolean *)key)->hash_key();
		hashtable->pairs[res.value] = pair;
	}

	return hashtable;
}

std::optional<std::string> VM::execute_index_expression(Object *left,
																												Object *index) {
	if (left->Type() == ObjType::Array && index->Type() == ObjType::Integer)
		return execute_array_index(left, index);
	else if (left->Type() == ObjType::Hash)
		return execute_hash_index(left, index);

	// the index operator is not supported for this type
	return "index expression is not supported for the type in question.";
}

std::optional<std::string> VM::execute_array_index(Object *arr, Object *index) {
	auto array = dynamic_cast<Array *>(arr);
	if (array == nullptr)
		return "object is not of type array.";

	auto idx = ((Integer *)index)->value;
	auto max = (int)array->elements.size() - 1;

	if (idx < 0 || idx > max) {
		return push(object_constant::null);
	}

	return push(array->elements[idx]);
}

std::optional<std::string> VM::execute_hash_index(Object *hash, Object *index) {
	auto hashobj = dynamic_cast<Hash *>(hash);
	if (hashobj == nullptr)
		return "object is not of type hash.";

	if (!(index->Type() == ObjType::Integer || index->Type() == ObjType::String ||
				index->Type() == ObjType::Boolean))
		return "type of index is invalid, needs to be 'int' 'bool' or 'string'";

	HashKey res;
	// we only need to check these types since the previous if expressions
	// guarantees that the object is one of them.
	if (index->Type() == ObjType::Integer)
		res = ((Integer *)index)->hash_key();
	else if (index->Type() == ObjType::String)
		res = ((String *)index)->hash_key();
	else if (index->Type() == ObjType::Boolean)
		res = ((Boolean *)index)->hash_key();

	if (hashobj->pairs.count(res.value) == 0)
		return push(object_constant::null);

	return push(hashobj->pairs[res.value]->value);
}

std::optional<std::string> VM::call_closure(Object *cl, int num_args) {
	const auto closure = dynamic_cast<Closure *>(cl);
	if (closure == nullptr)
		return "object is not of type closure.";

	if (num_args != closure->func_->m_num_parameters)
		return "the amount of arguments supplied differs from the amount of "
					 "parameters the function needs.";

	auto frame =
			std::make_unique<Frame>(closure->func_->m_instructions, sp_ - num_args);
	auto new_stack_ptr = frame->base_pointer_ + closure->func_->m_num_locals;
	push_frame(std::move(frame));
	sp_ = new_stack_ptr;

	return std::nullopt;
}

std::optional<std::string> VM::execute_call(int num_args) {
	const auto callee = stack_[sp_ - 1 - num_args];

	if (callee->Type() == ObjType::Closure)
		return call_closure(callee, num_args);
	else if (callee->Type() == ObjType::Builtin)
		return call_builtin(callee, num_args);

	// calling a non-function.
	return "calling a type that is not a function.";
}

std::optional<std::string> VM::call_builtin(Object *builtin, int num_args) {
	const auto builtin_func = dynamic_cast<Builtin *>(builtin);
	if (builtin_func == nullptr)
		return "the object is not of type builtin";

	auto args = std::vector<Object *>(stack_.begin() + sp_ - num_args,
																		stack_.begin() + sp_);
	auto res = (builtin_func->func(args));

	if (res != nullptr) {
		push(res);
	} else {
		push(object_constant::null);
	}

	return std::nullopt;
}

std::optional<std::string> VM::push_closure(int const_index, int num_free) {
	auto constant = constants_[const_index];

	auto fn = dynamic_cast<CompiledFunction *>(constant);
	if (fn == nullptr)
		return "the object is not of type 'CompiledFunction'";

	std::vector<Object *> free_vec(num_free, nullptr);
	for (int i = 0; i < num_free; ++i)
		free_vec[i] = stack_[sp_ - num_free + i];
	sp_ -= num_free;

	auto closure = new Closure(fn);
	closure->free_ = free_vec;

	return push(closure);
}
